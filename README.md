ppx_deriving
============

_ppx_deriving_ is a library that simplifies type-driven code generation that works on OCaml >=4.02.

_ppx_deriving_ includes a set of useful plugins: Show, (hopefully more in near future).

Installation
------------

_ppx_deriving_ can be installed via [OPAM](http://opam.ocaml.org) (not yet):

    opam install ppx_deriving

Usage
-----

From a user's perspective, _ppx_deriving_ is triggered by a `[@@deriving Plugin]` annotation attached to a type declaration in structure or signature:

``` ocaml
type point2d = float * float
[@@deriving Show]
```

It's possible to invoke several plugins by separating their names with commas:

``` ocaml
type point3d = float * float * float
[@@deriving Show, Eq]
```

It's possible to pass options to a plugin by appending a record to plugin's name:

``` ocaml
type t = string
[@@deriving Ord { affix = "" }]
```

It's possible to make _ppx_deriving_ ignore a missing plugin rather than raising an error by passing an `optional = true` option, for example, to enable conditional compilation:

``` ocaml
type addr = string * int
[@@deriving Json { optional = true }]
```

Plugin conventions
------------------

It is expected that all _ppx_deriving_ plugins will follow the same conventions, thus simplifying usage.

  * By default, the functions generated by a plugin for a `type foo` are called `fn_foo` or `foo_fn`. The defaults can be overridden by an `affix` plugin option.

  * There may be additional attributes attached to the AST. In case of a plugin named `Eq` and attributes named `compare` and `skip`, the plugin must recognize all of `compare`, `skip`, `eq.compare`, `eq.skip`, `deriving.eq.compare` and `deriving.eq.skip` annotations. However, if it detects that at least one namespaced (e.g. `eq.compare` or `deriving.eq.compare`) attribute is present, it must not look at any attributes located within a different namespace. As a result, different plugins can avoid interference even if they share attribute names.

  * If a type is parametric, the generated functions accept an argument for every type variable before all other arguments.

Plugin: Show
------------

_Show_ derives a function that inspects a value; that is, pretty-prints it with OCaml syntax. However, _Show_ offers more insight into the structure of values than the Obj-based pretty printers (e.g. `Printexc`), and more flexibility than the toplevel printer.

``` ocaml
# type t = [ `A | `B of int ] [@@deriving Show];;
type t = [ `A | `B of i ]
val pp_t : Format.formatter -> [< `A | `B of i ] -> unit = <fun>
val show_t : [< `A | `B of i ] -> bytes = <fun>

# show_t (`B 1);;
- : bytes = "`B 1"
```

_Show_ supports tuples, records, normal and polymorphic variants, builtin types `int`, `int32`, `int64`, `nativeint`, `float`, `bool`, `char`, `string`, `bytes` and their `Mod.t` aliases, and abstract types. For abstract type `t`, _Show_ expects to find a `pp_t` function in the same module, as it itself would generate.

_Show_ allows to specify custom formatters for types to override default behavior. A formatter for type `t` has a type `Format.formatter -> t -> unit`:

``` ocaml
# type file = {
  name : string;
  perm : int     [@printer fun fmt -> Format.fprintf fmt "0o%03o"];
} [@@deriving Show];;
# show_file { name = "dir"; perm = 0o755 };;
- : bytes = "{ name = \"dir\"; perm = 0o755 }"
```

Plugins: Eq and Ord
-------------------

_Eq_ derives a function comparing values by semantic equality; structural or physical depending on context. _Ord_ derives a function defining a total order for values, returning `-1`, `0` or `1`. They're similar to `Pervasives.(==)` and `Pervasives.compare`, but are faster, allow to customize the comparison rules, and never raise at runtime.

``` ocaml
TBD
```

_Eq_ and _Ord_ support tuples, records, normal and polymorphic variants, builtin types `int`, `int32`, `int64`, `nativeint`, `float`, `bool`, `char`, `string`, `bytes` and their `Mod.t` aliases, and abstract types. For builtin types, corresponding `Mod.compare` function (e.g. `String.compare` for `string`) is used for _Ord_, or properly monomorphized `(=)` for _Eq_. For abstract type `t`, _Eq_ and _Ord_ expect to find an `equal_t` or `compare_t` function in the same module, as _Eq_ or _Ord_ themselves would generate.

_Eq_ and _Ord_ allow to specify custom comparison functions for types to override default behavior. A comparator for type `t` has a type `t -> t -> bool` for _Eq_ or `t -> t -> int` for _Ord_.

``` ocaml
TBD
```

Developing plugins
------------------

TBD

API documentation is available [online](http://whitequark.github.io/ppx_deriving/).

Rationale
---------

TBD

License
-------

_ppx_deriving_ is distributed under the terms of [MIT license](LICENSE.txt).
